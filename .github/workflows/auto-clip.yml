<!-- START: Suno-mini â€” lightweight multimodal generator/player -->
<section id="sunoMini" style="margin-top:28px;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,215,102,0.01), rgba(255,215,102,0.005));border:1px solid rgba(255,215,102,0.04);">
  <h3 style="margin:0;color:#ffd966">ðŸŽš Suno Â· Mini â€” Omniverse Multimidia Studio (Free)</h3>
  <p style="color:#ddd;margin:8px 0 14px;">Text â†’ Voice, background loops, record & export. Create daily clips in one click.</p>

  <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start;">
    <div style="flex:1;min-width:280px">
      <label style="display:block;color:#ffd966;font-weight:700">Text to Speak</label>
      <textarea id="suno_text" placeholder="à¤¯à¤¹à¤¾à¤ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤²à¤¿à¤–à¥‡à¤‚ â€” à¤«à¤¿à¤° Generate à¤¦à¤¬à¤¾à¤à¤" style="width:100%;min-height:120px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.03);color:#fff;border:none"></textarea>

      <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
        <select id="suno_voice" style="padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);color:#fff;border:none">
          <option value="default">Browser TTS (default)</option>
        </select>

        <select id="suno_rate" style="padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);color:#fff;border:none">
          <option value="0.9">Rate 0.9</option>
          <option value="1" selected>Rate 1</option>
          <option value="1.1">Rate 1.1</option>
          <option value="1.2">Rate 1.2</option>
        </select>

        <button id="suno_generate" class="btn" style="background:#ffd966;color:#050505">Generate</button>
        <button id="suno_generate_daily" class="btn">Generate Daily Clip</button>
      </div>

      <div style="margin-top:12px">
        <label style="color:#ffd966;font-weight:700">Background Loop</label>
        <div style="display:flex;gap:8px;margin-top:6px">
          <button class="btn loopBtn" data-loop="pad">Calm Pad</button>
          <button class="btn loopBtn" data-loop="drums">Light Drums</button>
          <button class="btn loopBtn" data-loop="none">None</button>
        </div>
      </div>
    </div>

    <div style="width:360px;min-width:260px">
      <div style="background:rgba(0,0,0,0.45);padding:12px;border-radius:8px;">
        <div style="font-weight:700;color:#ffd966">Preview & Controls</div>
        <audio id="suno_preview" controls style="width:100%;margin-top:8px"></audio>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="suno_record" class="btn">Record Clip</button>
          <button id="suno_stop" class="btn">Stop</button>
          <a id="suno_download" class="btn" style="display:none" download="clip.wav">Download WAV</a>
        </div>

        <div style="margin-top:12px">
          <div style="font-weight:700;color:#ffd966">Library</div>
          <ul id="suno_library" style="list-style:none;padding:0;margin:8px 0;color:#ddd;max-height:160px;overflow:auto"></ul>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- Dependencies: Tone.js + Recorder.js (CDN) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
<script>
/* Suno-mini: client-side Textâ†’Speech + Tone loops + Recorder (no server) */

(async function(){
  // Elements
  const textEl = document.getElementById('suno_text');
  const voiceSel = document.getElementById('suno_voice');
  const rateSel = document.getElementById('suno_rate');
  const genBtn = document.getElementById('suno_generate');
  const dailyBtn = document.getElementById('suno_generate_daily');
  const preview = document.getElementById('suno_preview');
  const recordBtn = document.getElementById('suno_record');
  const stopBtn = document.getElementById('suno_stop');
  const downloadLink = document.getElementById('suno_download');
  const libraryEl = document.getElementById('suno_library');
  const loopBtns = document.querySelectorAll('.loopBtn');

  // Tone.js setup for background loops
  await Tone.start();
  let loopState = 'none';
  let loopPlayers = {};
  // simple sample URLs (public images host) - you can replace with your own small loops
  loopPlayers.pad = new Tone.Player("https://cdn.jsdelivr.net/gh/anshumanp/short-loops/pad-loop.mp3").toDestination();
  loopPlayers.drums = new Tone.Player("https://cdn.jsdelivr.net/gh/anshumanp/short-loops/drums-loop.mp3").toDestination();

  // voice list (populate browser voices)
  function loadVoices(){
    const synthVoices = speechSynthesis.getVoices() || [];
    voiceSel.innerHTML = '<option value="default">Browser TTS (default)</option>';
    synthVoices.forEach(v=>{
      const opt = document.createElement('option');
      opt.value = v.name;
      opt.text = v.name + (v.lang ? ' â€” ' + v.lang : '');
      voiceSel.appendChild(opt);
    });
  }
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;

  // helper: speak -> generate audio blob via MediaRecorder
  async function speakToBlob(text, rate=1, voiceName=null){
    return new Promise((resolve, reject)=>{
      const utter = new SpeechSynthesisUtterance(text);
      utter.rate = rate;
      if(voiceName && voiceName!=='default'){
        const v = speechSynthesis.getVoices().find(x=>x.name===voiceName);
        if(v) utter.voice = v;
      }
      // create audio destination: use AudioContext + MediaStreamDestination
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const dest = ctx.createMediaStreamDestination();
      // connect speechSynthesis? Browsers don't expose direct node for TTS â€” fallback: use utterance playback & capture from system audio via WebAudio is restricted.
      // Simpler approach: use speechSynthesis and capture using MediaRecorder of audio element by creating <audio> from SpeechSynthesis via offline approach.
      // Practical fallback: rely on speechSynthesis to play and record via WebAudio: use SpeechSynthesisUtterance with onstart/onend to time record from AudioContext mixer using Oscillator (approx).
      // Simpler and reliable approach for cross-browser: use the Web Speech API to speak and directly save by recording speakers is not universally supported.
      // So here we synthesize via SpeechSynthesis to an <audio> by using SpeechSynthesis and then capturing via MediaRecorder from AudioContext.createMediaElementSource
      // Implementation:
      const tmpAudio = document.createElement('audio');
      tmpAudio.style.display='none';
      document.body.appendChild(tmpAudio);

      // Create a blob URL from utterance by using SpeechSynthesis API won't give us audio directly.
      // So we will use SpeechSynthesis to play, and simultaneously record output via system capture if available.
      // Instead, use the Web Speech for preview, and for export we will render TTS using WebAudio oscillator fallback (simple tone for now)
      // -- For reliable export: we'll synthesize with WebAudio (basic voice) as fallback.
      // For the purpose of this lightweight tool, do this:
      // Create an OfflineAudioContext and render simple speech-like using Oscillator + AM â€” (very basic)
      // But that's complex; instead we'll implement recorder of final mix: user clicks "Record Clip" while previewing; recording captures Tone.js + playback from the browser.

      // For now, resolve with null â€” we will not implement full TTSâ†’blob here because of browser limitations.
      resolve(null);
    });
  }

  // Simpler practical workflow implemented:
  // - Generate preview: use speechSynthesis to play text (preview)
  // - Start loop via Tone, play TTS in preview, user presses "Record Clip" to record the mix (loop + preview) into WAV via MediaRecorder capturing from the tab (if browser supports getDisplayMedia)
  // This keeps everything client-only and practical.

  function previewSpeak(text, rate, voiceName){
    // play background loop if selected
    if(loopState!=='none' && loopPlayers[loopState]) loopPlayers[loopState].start();
    const utter = new SpeechSynthesisUtterance(text);
    utter.rate = rate;
    if(voiceName && voiceName!=='default'){
      const v = speechSynthesis.getVoices().find(x=>x.name===voiceName);
      if(v) utter.voice = v;
    }
    utter.onend = () => {
      if(loopState!=='none' && loopPlayers[loopState]) loopPlayers[loopState].stop();
    };
    speechSynthesis.cancel(); // stop previous
    speechSynthesis.speak(utter);
  }

  // loop button handlers
  loopBtns.forEach(b=>{
    b.addEventListener('click', ()=> {
      loopState = b.dataset.loop;
      loopBtns.forEach(x=>x.style.opacity = '0.65');
      b.style.opacity = '1';
    });
  });

  // library functions
  function saveClipToLibrary(name, blob){
    const list = JSON.parse(localStorage.getItem('sunoLib')||'[]');
    const url = URL.createObjectURL(blob);
    list.unshift({name:name||('clip-'+new Date().toISOString()), url, ts:new Date().toISOString()});
    localStorage.setItem('sunoLib', JSON.stringify(list));
    renderLibrary();
  }
  function renderLibrary(){
    const list = JSON.parse(localStorage.getItem('sunoLib')||'[]');
    libraryEl.innerHTML = '';
    list.forEach((it, idx)=>{
      const li = document.createElement('li');
      li.style.marginBottom='8px';
      li.innerHTML = `<div style="display:flex;gap:8px;align-items:center;">
        <audio src="${it.url}" controls style="width:200px"></audio>
        <div style="flex:1;color:#ddd"><div style="font-weight:700">${it.name}</div><div style="font-size:12px;color:#bfbfbf">${new Date(it.ts).toLocaleString()}</div></div>
        <a class="btn" href="${it.url}" download="clip-${idx}.wav">Download</a>
      </div>`;
      libraryEl.appendChild(li);
    });
  }
  renderLibrary();

  // Generate preview on button
  genBtn.addEventListener('click', ()=> {
    const text = textEl.value.trim();
    if(!text){ alert('à¤•à¥ƒà¤ªà¤¯à¤¾ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤²à¤¿à¤–à¥‡à¤‚'); return; }
    const rate = parseFloat(rateSel.value || '1');
    const voice = voiceSel.value;
    previewSpeak(text, rate, voice);
  });

  // Daily auto-generate: uses a template and current date
  dailyBtn.addEventListener('click', ()=>{
    const template = `Daily message â€” ${new Date().toLocaleDateString()}. à¤†à¤¶à¥€à¤°à¥à¤µà¤šà¤¨: à¤†à¤œ à¤¸à¤š à¤•à¤¾ à¤…à¤­à¥à¤¯à¤¾à¤¸ à¤•à¤°à¥‡à¤‚ à¤”à¤° à¤¶à¤¾à¤‚à¤¤à¤¿ à¤°à¤–à¥‡à¤‚à¥¤`;
    textEl.value = template;
    genBtn.click();
  });

  // Recording: capture the tab audio via getDisplayMedia (user must allow "System audio" in browser)
  let mediaRecorder = null, recordedChunks = [];
  recordBtn.addEventListener('click', async ()=>{
    // start Tone if loop selected
    if(loopState!=='none' && loopPlayers[loopState]) loopPlayers[loopState].start();
    // we request display capture with audio (some browsers support capturing tab audio)
    try{
      const stream = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: false });
      mediaRecorder = new MediaRecorder(stream);
      recordedChunks = [];
      mediaRecorder.ondataavailable = e => { if(e.data.size>0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        const blob = new Blob(recordedChunks, {type:'audio/webm'});
        // convert webm->wav not trivial; but many browsers support webm playback and download; we provide webm
        saveClipToLibrary('clip-'+new Date().toLocaleString(), blob);
        downloadLink.href = URL.createObjectURL(blob);
        downloadLink.style.display = 'inline-block';
        downloadLink.download = 'clip.webm';
        // stop any Tone loops
        if(loopState!=='none' && loopPlayers[loopState]) loopPlayers[loopState].stop();
      };
      mediaRecorder.start();
      alert('Recording started â€” speak now or play preview. Click Stop when done.');
    }catch(err){ alert('Recording unavailable: your browser may not allow tab audio capture. Use Chrome and allow "Share audio" when prompted.'); console.error(err); }
  });

  stopBtn.addEventListener('click', ()=>{
    if(mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop();
  });

  // Simple download / save: if user wants WAV they can re-encode offline or use online converters.
})();
</script>
<!-- END: Suno-mini -->
<!-- START: Suno-mini â€” lightweight multimodal generator/player -->
<section id="sunoMini" style="margin-top:28px;padding:16px;border-radius:12px;background:linear-gradient(180deg, rgba(255,215,102,0.01), rgba(255,215,102,0.005));border:1px solid rgba(255,215,102,0.04);">
  <h3 style="margin:0;color:#ffd966">ðŸŽš Suno Â· Mini â€” Omniverse Multimidia Studio (Free)</h3>
  <p style="color:#ddd;margin:8px 0 14px;">Text â†’ Voice, background loops, record & export. Create daily clips in one click.</p>

  <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start;">
    <div style="flex:1;min-width:280px">
      <label style="display:block;color:#ffd966;font-weight:700">Text to Speak</label>
      <textarea id="suno_text" placeholder="à¤¯à¤¹à¤¾à¤ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤²à¤¿à¤–à¥‡à¤‚ â€” à¤«à¤¿à¤° Generate à¤¦à¤¬à¤¾à¤à¤" style="width:100%;min-height:120px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.03);color:#fff;border:none"></textarea>

      <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
        <select id="suno_voice" style="padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);color:#fff;border:none">
          <option value="default">Browser TTS (default)</option>
        </select>

        <select id="suno_rate" style="padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);color:#fff;border:none">
          <option value="0.9">Rate 0.9</option>
          <option value="1" selected>Rate 1</option>
          <option value="1.1">Rate 1.1</option>
          <option value="1.2">Rate 1.2</option>
        </select>

        <button id="suno_generate" class="btn" style="background:#ffd966;color:#050505">Generate</button>
        <button id="suno_generate_daily" class="btn">Generate Daily Clip</button>
      </div>

      <div style="margin-top:12px">
        <label style="color:#ffd966;font-weight:700">Background Loop</label>
        <div style="display:flex;gap:8px;margin-top:6px">
          <button class="btn loopBtn" data-loop="pad">Calm Pad</button>
          <button class="btn loopBtn" data-loop="drums">Light Drums</button>
          <button class="btn loopBtn" data-loop="none">None</button>
        </div>
      </div>
    </div>

    <div style="width:360px;min-width:260px">
      <div style="background:rgba(0,0,0,0.45);padding:12px;border-radius:8px;">
        <div style="font-weight:700;color:#ffd966">Preview & Controls</div>
        <audio id="suno_preview" controls style="width:100%;margin-top:8px"></audio>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="suno_record" class="btn">Record Clip</button>
          <button id="suno_stop" class="btn">Stop</button>
          <a id="suno_download" class="btn" style="display:none" download="clip.wav">Download WAV</a>
        </div>

        <div style="margin-top:12px">
          <div style="font-weight:700;color:#ffd966">Library</div>
          <ul id="suno_library" style="list-style:none;padding:0;margin:8px 0;color:#ddd;max-height:160px;overflow:auto"></ul>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- Dependencies: Tone.js + Recorder.js (CDN) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
<script>
/* Suno-mini: client-side Textâ†’Speech + Tone loops + Recorder (no server) */

(async function(){
  // Elements
  const textEl = document.getElementById('suno_text');
  const voiceSel = document.getElementById('suno_voice');
  const rateSel = document.getElementById('suno_rate');
  const genBtn = document.getElementById('suno_generate');
  const dailyBtn = document.getElementById('suno_generate_daily');
  const preview = document.getElementById('suno_preview');
  const recordBtn = document.getElementById('suno_record');
  const stopBtn = document.getElementById('suno_stop');
  const downloadLink = document.getElementById('suno_download');
  const libraryEl = document.getElementById('suno_library');
  const loopBtns = document.querySelectorAll('.loopBtn');

  // Tone.js setup for background loops
  await Tone.start();
  let loopState = 'none';
  let loopPlayers = {};
  // simple sample URLs (public images host) - you can replace with your own small loops
  loopPlayers.pad = new Tone.Player("https://cdn.jsdelivr.net/gh/anshumanp/short-loops/pad-loop.mp3").toDestination();
  loopPlayers.drums = new Tone.Player("https://cdn.jsdelivr.net/gh/anshumanp/short-loops/drums-loop.mp3").toDestination();

  // voice list (populate browser voices)
  function loadVoices(){
    const synthVoices = speechSynthesis.getVoices() || [];
    voiceSel.innerHTML = '<option value="default">Browser TTS (default)</option>';
    synthVoices.forEach(v=>{
      const opt = document.createElement('option');
      opt.value = v.name;
      opt.text = v.name + (v.lang ? ' â€” ' + v.lang : '');
      voiceSel.appendChild(opt);
    });
  }
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;

  // helper: speak -> generate audio blob via MediaRecorder
  async function speakToBlob(text, rate=1, voiceName=null){
    return new Promise((resolve, reject)=>{
      const utter = new SpeechSynthesisUtterance(text);
      utter.rate = rate;
      if(voiceName && voiceName!=='default'){
        const v = speechSynthesis.getVoices().find(x=>x.name===voiceName);
        if(v) utter.voice = v;
      }
      // create audio destination: use AudioContext + MediaStreamDestination
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const dest = ctx.createMediaStreamDestination();
      // connect speechSynthesis? Browsers don't expose direct node for TTS â€” fallback: use utterance playback & capture from system audio via WebAudio is restricted.
      // Simpler approach: use speechSynthesis and capture using MediaRecorder of audio element by creating <audio> from SpeechSynthesis via offline approach.
      // Practical fallback: rely on speechSynthesis to play and record via WebAudio: use SpeechSynthesisUtterance with onstart/onend to time record from AudioContext mixer using Oscillator (approx).
      // Simpler and reliable approach for cross-browser: use the Web Speech API to speak and directly save by recording speakers is not universally supported.
      // So here we synthesize via SpeechSynthesis to an <audio> by using SpeechSynthesis and then capturing via MediaRecorder from AudioContext.createMediaElementSource
      // Implementation:
      const tmpAudio = document.createElement('audio');
      tmpAudio.style.display='none';
      document.body.appendChild(tmpAudio);

      // Create a blob URL from utterance by using SpeechSynthesis API won't give us audio directly.
      // So we will use SpeechSynthesis to play, and simultaneously record output via system capture if available.
      // Instead, use the Web Speech for preview, and for export we will render TTS using WebAudio oscillator fallback (simple tone for now)
      // -- For reliable export: we'll synthesize with WebAudio (basic voice) as fallback.
      // For the purpose of this lightweight tool, do this:
      // Create an OfflineAudioContext and render simple speech-like using Oscillator + AM â€” (very basic)
      // But that's complex; instead we'll implement recorder of final mix: user clicks "Record Clip" while previewing; recording captures Tone.js + playback from the browser.

      // For now, resolve with null â€” we will not implement full TTSâ†’blob here because of browser limitations.
      resolve(null);
    });
  }

  // Simpler practical workflow implemented:
  // - Generate preview: use speechSynthesis to play text (preview)
  // - Start loop via Tone, play TTS in preview, user presses "Record Clip" to record the mix (loop + preview) into WAV via MediaRecorder capturing from the tab (if browser supports getDisplayMedia)
  // This keeps everything client-only and practical.

  function previewSpeak(text, rate, voiceName){
    // play background loop if selected
    if(loopState!=='none' && loopPlayers[loopState]) loopPlayers[loopState].start();
    const utter = new SpeechSynthesisUtterance(text);
    utter.rate = rate;
    if(voiceName && voiceName!=='default'){
      const v = speechSynthesis.getVoices().find(x=>x.name===voiceName);
      if(v) utter.voice = v;
    }
    utter.onend = () => {
      if(loopState!=='none' && loopPlayers[loopState]) loopPlayers[loopState].stop();
    };
    speechSynthesis.cancel(); // stop previous
    speechSynthesis.speak(utter);
  }

  // loop button handlers
  loopBtns.forEach(b=>{
    b.addEventListener('click', ()=> {
      loopState = b.dataset.loop;
      loopBtns.forEach(x=>x.style.opacity = '0.65');
      b.style.opacity = '1';
    });
  });

  // library functions
  function saveClipToLibrary(name, blob){
    const list = JSON.parse(localStorage.getItem('sunoLib')||'[]');
    const url = URL.createObjectURL(blob);
    list.unshift({name:name||('clip-'+new Date().toISOString()), url, ts:new Date().toISOString()});
    localStorage.setItem('sunoLib', JSON.stringify(list));
    renderLibrary();
  }
  function renderLibrary(){
    const list = JSON.parse(localStorage.getItem('sunoLib')||'[]');
    libraryEl.innerHTML = '';
    list.forEach((it, idx)=>{
      const li = document.createElement('li');
      li.style.marginBottom='8px';
      li.innerHTML = `<div style="display:flex;gap:8px;align-items:center;">
        <audio src="${it.url}" controls style="width:200px"></audio>
        <div style="flex:1;color:#ddd"><div style="font-weight:700">${it.name}</div><div style="font-size:12px;color:#bfbfbf">${new Date(it.ts).toLocaleString()}</div></div>
        <a class="btn" href="${it.url}" download="clip-${idx}.wav">Download</a>
      </div>`;
      libraryEl.appendChild(li);
    });
  }
  renderLibrary();

  // Generate preview on button
  genBtn.addEventListener('click', ()=> {
    const text = textEl.value.trim();
    if(!text){ alert('à¤•à¥ƒà¤ªà¤¯à¤¾ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤²à¤¿à¤–à¥‡à¤‚'); return; }
    const rate = parseFloat(rateSel.value || '1');
    const voice = voiceSel.value;
    previewSpeak(text, rate, voice);
  });

  // Daily auto-generate: uses a template and current date
  dailyBtn.addEventListener('click', ()=>{
    const template = `Daily message â€” ${new Date().toLocaleDateString()}. à¤†à¤¶à¥€à¤°à¥à¤µà¤šà¤¨: à¤†à¤œ à¤¸à¤š à¤•à¤¾ à¤…à¤­à¥à¤¯à¤¾à¤¸ à¤•à¤°à¥‡à¤‚ à¤”à¤° à¤¶à¤¾à¤‚à¤¤à¤¿ à¤°à¤–à¥‡à¤‚à¥¤`;
    textEl.value = template;
    genBtn.click();
  });

  // Recording: capture the tab audio via getDisplayMedia (user must allow "System audio" in browser)
  let mediaRecorder = null, recordedChunks = [];
  recordBtn.addEventListener('click', async ()=>{
    // start Tone if loop selected
    if(loopState!=='none' && loopPlayers[loopState]) loopPlayers[loopState].start();
    // we request display capture with audio (some browsers support capturing tab audio)
    try{
      const stream = await navigator.mediaDevices.getDisplayMedia({ audio: true, video: false });
      mediaRecorder = new MediaRecorder(stream);
      recordedChunks = [];
      mediaRecorder.ondataavailable = e => { if(e.data.size>0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        const blob = new Blob(recordedChunks, {type:'audio/webm'});
        // convert webm->wav not trivial; but many browsers support webm playback and download; we provide webm
        saveClipToLibrary('clip-'+new Date().toLocaleString(), blob);
        downloadLink.href = URL.createObjectURL(blob);
        downloadLink.style.display = 'inline-block';
        downloadLink.download = 'clip.webm';
        // stop any Tone loops
        if(loopState!=='none' && loopPlayers[loopState]) loopPlayers[loopState].stop();
      };
      mediaRecorder.start();
      alert('Recording started â€” speak now or play preview. Click Stop when done.');
    }catch(err){ alert('Recording unavailable: your browser may not allow tab audio capture. Use Chrome and allow "Share audio" when prompted.'); console.error(err); }
  });

  stopBtn.addEventListener('click', ()=>{
    if(mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop();
  });

  // Simple download / save: if user wants WAV they can re-encode offline or use online converters.
})();
</script>
<!-- END: Suno-mini -->
